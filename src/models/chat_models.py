from sqlalchemy import Column, Integer, String, DateTime, Text, Float, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid

Base = declarative_base()


class Question(Base):
    """
    Entity: Question
    Description: A user query submitted to the RAG system
    """
    __tablename__ = "questions"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    content = Column(Text, nullable=False)  # The text of the user's question
    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)  # When the question was submitted
    session_id = Column(String, nullable=True)  # Identifier for the conversation session
    source_mode = Column(String(20), nullable=False)  # How the question was submitted ('full' or 'selected')

    # Relationship to Answer (one-to-one, optional)
    answer = relationship("Answer", uselist=False, back_populates="question", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Question(id={self.id}, content='{self.content[:50]}...')>"


class Answer(Base):
    """
    Entity: Answer
    Description: A response generated by the OpenAI agent based on retrieved context
    """
    __tablename__ = "answers"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    question_id = Column(String, ForeignKey("questions.id"), nullable=False)  # Reference to the original question
    content = Column(Text, nullable=False)  # The text content of the answer
    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)  # When the answer was generated
    session_id = Column(String, nullable=True)  # Identifier for the conversation session
    source_chunks = Column(String, nullable=True)  # References to the chunks that informed the answer (JSON string)
    confidence_score = Column(Float, nullable=True)  # Agent's confidence in the answer

    # Relationship to Question
    question = relationship("Question", back_populates="answer")

    # Relationship to Log Entry (one-to-one)
    log_entry = relationship("LogEntry", uselist=False, back_populates="answer", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Answer(id={self.id}, question_id={self.question_id})>"


class RetrievedContext(Base):
    """
    Entity: Retrieved Context
    Description: A set of relevant text chunks retrieved from the vector database
    """
    __tablename__ = "retrieved_contexts"

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    question_id = Column(String, ForeignKey("questions.id"), nullable=False)  # Reference to the original question
    chunks = Column(Text, nullable=False)  # Array of relevant content chunks (JSON string)
    relevance_scores = Column(Text, nullable=False)  # Similarity scores for each chunk (JSON string)
    retrieval_timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)  # When the retrieval was performed

    # Relationship to Question
    question = relationship("Question", back_populates="retrieved_contexts")

    def __repr__(self):
        return f"<RetrievedContext(question_id={self.question_id})>"


# Add relationship to Question model after all classes are defined
Question.retrieved_contexts = relationship("RetrievedContext", back_populates="question", cascade="all, delete-orphan")